{"ast":null,"code":"const {\n  defaultArgs,\n  baseOptions\n} = require('./config');\n\nconst {\n  setLogging,\n  setCustomLogger,\n  log\n} = require('./utils/log');\n\nconst parseProgress = require('./utils/parseProgress');\n\nconst parseArgs = require('./utils/parseArgs');\n\nconst {\n  defaultOptions,\n  getCreateFFmpegCore\n} = require('./node');\n\nconst {\n  version\n} = require('../package.json');\n\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = (_options = {}) => {\n  const {\n    log: logging,\n    logger,\n    progress: optProgress,\n    ...options\n  } = { ...baseOptions,\n    ...defaultOptions,\n    ..._options\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let running = false;\n  let progress = optProgress;\n\n  const detectCompletion = message => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      running = false;\n    }\n  };\n\n  const parseMessage = ({\n    type,\n    message\n  }) => {\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n\n\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      const createFFmpegCore = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        printErr: message => parseMessage({\n          type: 'fferr',\n          message\n        }),\n        print: message => parseMessage({\n          type: 'ffout',\n          message\n        }),\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined' && typeof window.FFMPEG_CORE_WORKER_SCRIPT !== 'undefined' && path.endsWith('ffmpeg-core.worker.js')) {\n            return window.FFMPEG_CORE_WORKER_SCRIPT;\n          }\n\n          return prefix + path;\n        }\n      });\n      ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n  /*\n   * Determine whether the Core is loaded.\n   */\n\n\n  const isLoaded = () => Core !== null;\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n\n\n  const run = (..._args) => {\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise(resolve => {\n        const args = [...defaultArgs, ..._args].filter(s => s.length !== 0);\n        runResolve = resolve;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n\n\n  const FS = (method, ...args) => {\n    log('info', `run FS.${method} ${args.map(arg => typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`).join(' ')}`);\n\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n\n      return ret;\n    }\n  };\n\n  const setProgress = _progress => {\n    progress = _progress;\n  };\n\n  const setLogger = _logger => {\n    setCustomLogger(_logger);\n  };\n\n  setLogging(logging);\n  setCustomLogger(logger);\n  log('info', `use ffmpeg.wasm v${version}`);\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    FS\n  };\n};","map":{"version":3,"sources":["C:/Users/z00s600199/OJT/my-app-typescript/node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js"],"names":["defaultArgs","baseOptions","require","setLogging","setCustomLogger","log","parseProgress","parseArgs","defaultOptions","getCreateFFmpegCore","version","NO_LOAD","Error","module","exports","_options","logging","logger","progress","optProgress","options","Core","ffmpeg","runResolve","running","detectCompletion","message","parseMessage","type","load","createFFmpegCore","printErr","print","locateFile","path","prefix","window","FFMPEG_CORE_WORKER_SCRIPT","endsWith","cwrap","isLoaded","run","_args","join","Promise","resolve","args","filter","s","length","FS","method","map","arg","ret","e","setProgress","_progress","setLogger","_logger"],"mappings":"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","sourcesContent":["const { defaultArgs, baseOptions } = require('./config');\nconst { setLogging, setCustomLogger, log } = require('./utils/log');\nconst parseProgress = require('./utils/parseProgress');\nconst parseArgs = require('./utils/parseArgs');\nconst { defaultOptions, getCreateFFmpegCore } = require('./node');\nconst { version } = require('../package.json');\n\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = (_options = {}) => {\n  const {\n    log: logging,\n    logger,\n    progress: optProgress,\n    ...options\n  } = {\n    ...baseOptions,\n    ...defaultOptions,\n    ..._options,\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let running = false;\n  let progress = optProgress;\n  const detectCompletion = (message) => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      running = false;\n    }\n  };\n  const parseMessage = ({ type, message }) => {\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      const createFFmpegCore = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        printErr: (message) => parseMessage({ type: 'fferr', message }),\n        print: (message) => parseMessage({ type: 'ffout', message }),\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined'\n            && typeof window.FFMPEG_CORE_WORKER_SCRIPT !== 'undefined'\n            && path.endsWith('ffmpeg-core.worker.js')) {\n            return window.FFMPEG_CORE_WORKER_SCRIPT;\n          }\n          return prefix + path;\n        },\n      });\n      ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n\n\n  /*\n   * Determine whether the Core is loaded.\n   */\n  const isLoaded = () => Core !== null;\n\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n  const run = (..._args) => {\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise((resolve) => {\n        const args = [...defaultArgs, ..._args].filter((s) => s.length !== 0);\n        runResolve = resolve;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n  const FS = (method, ...args) => {\n    log('info', `run FS.${method} ${args.map((arg) => (typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`)).join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n      return ret;\n    }\n  };\n\n  const setProgress = (_progress) => {\n    progress = _progress;\n  };\n\n  const setLogger = (_logger) => {\n    setCustomLogger(_logger);\n  };\n\n  setLogging(logging);\n  setCustomLogger(logger);\n\n  log('info', `use ffmpeg.wasm v${version}`);\n\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    FS,\n  };\n};\n"]},"metadata":{},"sourceType":"script"}